The core issue is that you’re calling the HashPack extension’s JSON-RPC methods directly (e.g. hashpack.request({ method: 'hedera_getAccountInfo' })), without first completing the HashConnect handshake that exchanges the encryption keys. That means when you do get a response it’s still encrypted—and you have no way to decrypt it, hence the “Invalid encrypted text” error.

What’s wrong
No HashConnect init/pairing
HashPack’s extension API expects you to pair via HashConnect first (that generates and shares an encryptionKey).

Unsupported RPC methods
Methods like 'hedera_getAccountInfo' or 'eth_requestAccounts' aren’t part of the HashPack extension’s JSON-RPC surface—you’ll never hit the true unencrypted payload.

Mixing direct extension calls and HashConnect
You either use the low-level HashConnect library (which handles all key exchange) or you implement your own full E2E encryption handshake against the extension. Your code does neither.

How to fix
Switch entirely to the HashConnect flow. Here’s a complete, ready-to-drop-in connector (no placeholders) that:

Initializes HashConnect

Pairs to the wallet extension (so you share an encryptionKey)

Emits the Hedera account ID once connected

ts
Copy
Edit
import { HashConnect, HashConnectTypes } from "hashconnect";

const APP_METADATA: HashConnectTypes.AppMetadata = {
  name:        "MyDApp",
  description: "Connect your HashPack wallet",
  icon:        "https://mydapp.com/logo.png"
};

// choose “testnet” or “mainnet” here:
const NETWORK: "testnet" | "mainnet" = "testnet";

export class HashPackConnector {
  private hashconnect: HashConnect;
  private topic:       string | null = null;
  private pairedAccount: string | null = null;

  constructor() {
    this.hashconnect = new HashConnect();
  }

  async connect(): Promise<string> {
    if (this.pairedAccount) return this.pairedAccount;

    // 1. init (generates private/encryption keys)
    const initData = await this.hashconnect.init(
      APP_METADATA,
      NETWORK,
      false,
      {} // no saved privKey
    );

    // 2. create pairing (opens QR/extension popup)
    const { topic, pairingString } = initData;
    this.topic = topic;
    await this.hashconnect.connect({ pairingString });

    // 3. listen for when user approves in wallet
    return new Promise((resolve, reject) => {
      this.hashconnect.pairingEvent.once((pairing) => {
        if (
          pairing.accountIds &&
          pairing.accountIds.length > 0 &&
          pairing.network === NETWORK
        ) {
          this.pairedAccount = pairing.accountIds[0];
          resolve(this.pairedAccount);
        } else {
          reject(new Error("No Hedera account returned"));
        }
      });

      // handle reject/timeout yourself if you want
    });
  }

  getAccount(): string | null {
    return this.pairedAccount;
  }

  disconnect(): void {
    if (this.topic) {
      this.hashconnect.disconnect(this.topic);
      this.topic = null;
    }
    this.pairedAccount = null;
  }
}

// singleton
export const hashPackConnector = new HashPackConnector();
Why this works:

init() generates your keypair and encryptionKey.

connect({ pairingString }) pops open HashPack’s approval UI (QR or extension).

Once the user approves, the extension shares you the plaintext account ID.

From here you can call any Hedera RPC methods through HashConnect’s hashconnect.sendTransaction() or similar, and everything is correctly encrypted/decrypted.

Let me know if you need help integrating transfers or contract calls over this same setup!